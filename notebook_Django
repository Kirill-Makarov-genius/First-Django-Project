I. Подготовка к Django -------------------------------------------------------------------------------------------------------------------------

1) Создание виртуального окружения (venv)
    1. python -m venv <название виртуального окружения> - создать виртуальное окуржение
    2. .\venv\Scripts\activate - запускаем виртуальную среду посредсвом указания пути к файлу activate
    3. deactivate - для выхода из виртуального окружения

2) Скачивание библиотеки Django  и запуск проекта
    1. pip install Django - скачиваем Django в нашу виртуальную среду(venv)
    2. django-admin startproject <название проекта> - создаём проект
    3. python manage.py runserver - запуск проект на локальном сервере.
    
3) Модель MTV(Models, Templates, Views):
    1. Model - База данных
    2. Template - Шаблон страницы
    3. View - Представление(Контроллеры), которое объединяет Model и Template.

4) Алгоритм работы MTV:
    1. Запрос от пользователя -> Представление(View) -> Собирается страница по шаблону(Template), наполненная данными из модели(Model)

II. Настройка и создания приложения(App)----------------------------------------------------------------------------------------------------------------

1) python manage.py startapp <названия приложения> и его состовляющие:
    1. admin.py - Связь с админ-панелью сайта
    2. apps.py - Настроки текущего приложения
    3. models.py - Хранение ORM-моделей, т.е. для представления баз данных
    4. tests.py - Используется для тестов над сайтом.
    5. views.py - Контроллер текущего приложения

2) Регистрирование приложения в нашем проекте:
    1. Переходим в основную папку проекта и заходим в settings.py
    
    2. Находим список INSTALLED_APPS и дописываем в него путь, который представляет из себя обращения к классу конфигурации(AppConfig) внутри apps.py 
    созданного приложения
    
    3. <название приложения>.apps.<Название приложения>Config

3) Создание представавления(View) для нашего app:
    1. В катологе созданного нами APP переходим в views.py
    
    2. Создаём функцию, которая будет возвращать какой-то ответ(Response) на сайт при вызове её путём перехода по ссылке приложения.
    Example: def <название функции>(request):
        return HttpResponse(...)
4) Маршрутизация представления или же создание url-адреса для нашего представления(View)
    1. Переходим в основной каталог сайта и открываем urls.py
    
    2. Импортируем представавление(View) - from <приложение(App)>.views import <фунция представления>
   
    3. В список urlpatterns добавляем функцию path с аргументами:
        а) Желаемый url
        б) Импортированная функция, которая будет вызываться при переходе по вышеуказанному url-у.
        Example: path('women/', index)
        в) Результат: http://127.0.0.1:8000/women/. Если декомпозировать, то получаем протокол(http://) доменное имя(//127.0.0.1:8000/) и сам url(women/)
5) Правильная маршрутизация(Принцип независимости приложений):
    1. В urls.py основного каталога проетка импортируем функцию include. from django.urls import indclude
    
    2. В функции path вместо указания сразу импортированной функции из views запишем функцию Django, которая будет ссылаться на urls.py нашего приложения
    Example: path('women/', include('women.urls'))
    
    3. А в urls.py создаём свой список с продолжением пути url от значения, указанного в первоначальном path

III. Углублённая маршрутизация-----------------------------------------------------------------------------------------------------------------------------

1) Добавление id страницы. Т.Е. добавление к url-у обязательного параметра в виде числа, интегрируемого в ссыллку. "http:/127.0.0.1:8000/categories/11/", где 11 - это параметр, который мы не прописывали в ручную в url, а смогли интегрировать при помощи конструкции "categories/<int:catid>"
    1. Заходим в urls нашего app и к обычному url добавляем следующую конструкцию "обычный url/<int:название переменной для дальнейшего использования>" 
    
    2. Дабы вывести наш id, полученный во время запроса к сайту, мы укажем нашей функции в Views, чтобы получала не только request, но ещё и id
    Example: def categories(request, page_id):
2)Вместо int также можно использовать slug.
    1. slug - принимает все букваы латинского алфавита и цифры

Addition. Post и Get запросы и их обработка: 
    1. Пример get-Запроса: http://127.0.0.1:8000/women/categories/sport/?name=Kirll&iq=250
    
    2. То что идёт после знака вопрос будет обрабатываться как словарь. {"name": "Kirill", "iq": 250}

IV. Обработка исключений при запросах:--------------------------------------------------------------------------------------------------------------------

1)Отключаем DEBUG в settings.py
    1. В список ALLOWED_HOSTS(Доступные хосты) добавим локальный IP(127.0.0.1)
    
    2. DEBUG = False
2)Создаём обработчик(handler) для ошибок 404
    1. В urls.py(основной) указываем специальной переменной handler404,чтобы при ошибке она ссылалась на функцию из views, которая содержит ответ к сайт.Присваивание функций к переменным ошибок(handler404, handler500, handler403) происходит без скобок
    Example: handler404 = pageNotFound 
    
    2. В views.py создаём функцию pageNotFound() ОБЯЗАТЕЛЬНО с аргументами request и exception
    
    3. При вызове функции возвращаем не просто HttpResponse(), а HttpResponseNotFound(<блок html кода>)
3)Генарация специальных ошибок для Views функций.
    1. raise HTTP404() - генерирует ошибку 404 и автоматически вызвается наш обработчик handler404.
    Example: def market_list(request, page):
        if page > 30:
            raise HTTP404()
        ...
        return None

V. Redirect-ы и именование маршрутов:--------------------------------------------------------------------------------------------------------------------

1) Определение и создание redirect
    1. redirect - это обычное перенаправление, например когда вводишь в интренет-магазине слишком большую страницу, то он переносит тебя на первую
    
    2. redirect(<куда перенаправить(url, name)>, permanet=True), permanet использует для обозначения постоянных и временных redirect-ов
    Example: def def market_list(request, page):
        if page > 1000:
            return redirect("home", permanet=True )
2) Наименования маршрутов.
    1. Используется для поддержания более независимой структуры проекта
    
    2. path("home/", index, name="main")
    
    3. Теперь можно обращаться по имени

VI. Определение моделей(Models).---------------------------------------------------------------------------------------------------

1) Создание модели:
    1. Определяем структуру модели у себя в голове. Какие нужны поля и какие у них типы данных.
    
    2. Переходим в models.py нужного нам app
    
    3. Создаём класс, который наследует models.Model, чтобы работать с классом как с универсальной таблицей.
    
    4. Внутри класса прописываем поля и их типы.
    Example: class Women(models.Model):
        title = models.CharField(max_length = 250)
        photo = models.ImageField()
        ...
2) Опредение типов полей и их особенности
    1. CharField есть параметр max_length, чтобы задать максимальную длину
    
    2. В Photo нужно узнать обязательный параметр upload_to, который содержит путь к католгу с фотографиями куда мы будет загружать изображения
    
    3. У поляе DateTimeField есть 2 разлиных параметра. auto_update_add - для обновлнеия времени единожды и auto_update = для обнолвения времени при каждом изменении
    
    4. BoleadnFiled можно присвоить значение по умолчанию при помощи параметра default.
3) Создание католога для изобржений ImageField:
    1. В settings.py создаём 2 специльных переменных
    
    2. MEDIA_ROOT - это абсолютный путь к подкатологу с графическими изображениями
    
    3. MEDIA_URL - это отностиельный url-адрес по которому вы обращаетись ко всем медиа файлом
    Example: MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
    MEDIA_URL = '/media/'
4) Симуляцияя реального сервера, чтобы мы могли получать изображения даже в режиме DEBUG на локальном сервере
    1. Переходим в urls.py основного каталога
    
    2. Создаём условие, чтобы она работало только во время процесса DEBUG, поскольку на реальном сервере этого уже не требуется
    
    3. В блоке условия добавляем к списку urlpatterns статический файл(static) путём функции static() и присаиваем ей следующие аргументы:
        а) settings.MEDIA_URL - url, при запросе, которого всё перенаправляется на MEDIA_ROOT 
        б) document_root = settings.MEDIA_ROOT - полный путь к катологу медиа, откуда вызваются изображения

VII.Миграции и всё что с ними связано--------------------------------------------------------------------------------------------------------------------

1) Что предстваляет из себя миграция
    1. миграции - это такая система контроля версия для баз данных. В мигрциях отображаются всё изменения связанные с таблицами Баз данных и их описания, 
    например что конретно изменилось, моэет какое-то поле добавилось.

2) Полная работас с миграциями
    1. Создание миграции.python manage.py makemigrations - создаёт миграции и в папке migrations нашего app. Создаётся новый файл с номером изменения(0001)а внутри него уже показаны сами измения с базой данных, а конкретно в списке operations().
    
    2. SQL запрос к миграции(Только посмотреть).python manage.py sqlmigrate <название app, где храниться нужная миграция> <номер миграции> - Показывает какой SQL запрос будет выполнен для данной миграции.
    Example: python manage.py sqlmigrate women 0001
    
    3. Выполнение миграции. python manage.py migrate - Выполняет миграции, то есть производит всё изменения прописанные внутри них.

VIII. Основы работы с моделями------------------------------------------------------------------------------------------------------------------------

1) Основы работы с ORM через встроенную консоль Django shell.
    1. Через консоль входим в оболочку. python manage.py shell
    
    2. Импортируем нужную модель. from <путь к катологу моделей app> import <название модели>
    Example: from women.models import Women
    
    3. Создаём запись, которую впоследствии нужно ещё сохранить. <Класс модели>(присваиваем нужные параметры)
    Example: Women(title="Кирилл Макаров", content="Биография Кирилла Макарова")
    
    4. Для сохранения можем использовать знак "_" - он сохраняет последний объект. <переменная> = _
    Example: w1 = _
    
    5. Теперь можем сохранить переменную в БД. <переменная>.save()
    Example: w1.save()
2) Отображение работы базы данных или же SQL-запросов.
    1. Импортируем в консоль модуль connection из django.db. from django.db import connection
    
    2. И можем посмотреть все совершенный запросы к базе данных. connection.queries
3) Менеджер модели(objects).
    1. Менеджер модели отличается тем, что он не является ленивым. Ты работаешь с записями таблицы напрямую
    
    2. Запись данных. <Класс модели>.objects.create(параметры записи)
    Example: Women.objects.create(title="Кирилл Макаров", content="Биография Кирилла Макарова")
    
    3. Чтение данных.
        а) <Класс модели>.objects.all() - Выволит все данные таблицы в виде QuerySet-а, который представляет из себя список
        б) <Класс модели>.objects.filter(условие) - выводит только записи подходящие под определенно строгое условие.   
        условия и сортировка:
            а) pk >= 2 в filter записывается вот так: pk__gte = 2 
            б) pk <= 2 в filter записывается вот так: pk__lte = 2
            в) Услвоия пишутся через запятую.
            Example: 2 <= pk <= 5 в filter(pk__lte=5, pk__gte=2)
            г) после уловия можно добавить сортировку по параметру. ...filter(условие).order_by(параметр). Порядок сортировка корректируется при помощи выставления "-" перед парметром. order_by("-title")
        в) <Класс модели>.objects.exclude(условие) - выводи все записи, за исключением того, что подходит под условие
        г) <Класс модели>.objects.get(условие) - Возвращает конкретно 1 элемент подходящий под условие. Не обрабатывает исключение, выдаёт ошибки
    
    4. Изменение данных в таблице.
        а) присваиваем переменной какой-либо объекта таблицы, а затем удаляем его.
        Example: woman1.delete()
        б) присваиваем переменной какой-либо объекта таблицы, а затем заменяем его параметры по 1.
        Example: woman1.title = "Кирилл Макаров"
        woman1.content = "Биография Кирилла Макарова"

Addition. Измения отображения имени объекта:
    1) Изменения отображения объекта модели при вызове. Чтобы было не "Women object (1)", а то что ты хочешь
    1. В классе с моделью нужно прописать специальный метод(__str__), который будет изменять наименове объекта.
    Examplt: Class <модель>(models.Model):
        ...
        def __str__(self):
            return self.title

IX. Шаблоные: основы ----------------------------------------------------------------------------------------------------------------------------------

1) Создание каталога templates
    1. В катологе нашего app создаём каталог templates. #.../site/women/templates
    
    2. Затем в каталоге templates дополнительно создаём ещё 1 каталог с название нашего app. #.../site/women/templates/women
    
    3. Так делается для того, чтобы избежать возможных ошибок совмещения, поскольку при выгрузке проекта на все шаблоны собираются в 1 папку на сервере.
    
    4. Затем уже создаём html-файл в катологе. #.../site/women/templates/women/index.html
2) View возвращает шаблон

    1. Переходим в Views.py
    
    2. Указываем функци, чтобы она при возвращении рендерила шаблон и выводила его. return render(request, <путь к шаблону>, <данные в виде словаря>)
    Example: return render(request, "women/index.html") - возвращает классическую html-страницу.
    
    3. Заметь, что путь мы указываем отталкиваясь от того, что мы же в катологе templates. Так происходит, потому что Django изнчально находит каталог templates и уже от него строит маршруты при обработке шаблона.
    
    4. Чтобы передать шаблону параметры так же использум render(), но в этот раз уже 3 аргументом добавляем словарь.
    Example: return render(request, "women/about.html", {'title': О странице})

3) Рациональное использование шаблонов. DRY - Don't Repeat Yourself
    1. Для начал создадим основной шаблон, от которого и будем в дальнейшем отталкиваться(Пропишем header, footer, contaner)
    
    2. Создаём допоняющие шаблоны(extend), чтобы заполнять страницу не переписывая html-код заново, а просто добавив нужную часть в наш основной шаблон.
    
    3. Сделать всё это можно при помощи вставки блоков ( {% block <название> %}{% endblock %} ) в основной шаблон. 
    
    4. Затем в дополняющих html-файлах прописываем расширение {% extends <путь к расширяемому шаблону> %}, а затем пропишем содержание блоков( {% block <название> %}<html-код>{% endblock %} )

4) Работа с моделями в шаблонах:
    1. Импортируем модель в views.py. from .models import *
    
    2. Создаём переменную, к которой присваиваем содержание нужной нам модели при помощи объктного менеджера. data_model = <Модель>.objects.all()
    
    3. Вносим в наш словарь переменную с записью модели.
    
    4. В шаблон проходимся циклом for по записям модели(QuerySet).
    
    5. Вызывая запись модели обращаемся к ней по атрибуту(item.title), поскольку запись в модели представляет из себя объект с определенными атрибутами(характеристики записи)

X. Статические файлы: Подготовка--------------------------------------------------------------------------------------------------------------------------

1) Особенность хранения static фаилов
    1. Хранения статических файлох делят на 2 способа:
        а) Классический. Аналогично хранению templates, в app-каталогах
        б) Не стандартный. Хранится в основной параметр в основ каталоге проекта
    
    2. После того как мы уже создали static-каталоги, в косноли требуется пропсать команду для объединения всех файлов в каталог для вэб-сервера.
    Example: python manage.py collectstatic

2) Для работы фукнционала статических файлов нужно определить 3 константы в settings.py.
    1. STATIC_URL - префикс для url-адресов, которые мы будем подключать в шаблонах
    2. STATIC_ROOT - путь к основному католога всех динамических файлов
    3. STATICFILES_DIRS - список путей к нестандарным статическим файлам

3) Создание нужных каталогов для статическах файлов
    1. В app создаём каталог static. #...site/women/static
    2. Создаём ещё один каталог для создания пространства имён. #...site/women/static/women
    3. И внутри этого подкаталога создаём следующие папки:
        а) css #...site/women/static/women/css
        б) js #...site/women/static/women/js
        в) images #...site/women/static/women/images
    4. Создаём styles.css в каталоге css
    5. Загружаем фотографии веб-сайта в images

XI. Статические файлы. Интегрирование в HTML -------------------------------------------------------------------------------------------------------------

1) Подкючаем CSS к HTML-документу.
    1. В начало документа html прописываем конструкцию {% load static %}
    
    2. Добавляем классическую ссылку на css-file, но путь записываем иначе. href = "{% static <путь к css файлу отностельно каталога static> %}"
    Example: <link type="text/css" href="{% static 'women/css/styles.css' %}" rel="stylesheet">
    
    3. Чтобы добавить изображение к вкладке в браузере: <link rel="shortcut icon" href="{% static 'women/images/main.ico' %}" type="image/x-icon"/>
2) Фильтры шаблонов.
    1. Фильтры шаблонов - это набор конструкций, записывающихся через запятую, которые испольлзуются для форматирования поступающих данных из БД или для совершения каких-либо математическиз операция над ними.
    Формат записи: {{ <данные> | <1-й фильтр> | <2-й фильтр> | ...}}
    Example: {{ actress.content | linebreaks | truncatewords:100 }}

XII. url-адреса в шаблонах. ------------------------------------------------------------------------------------------------------------------------------

1) Создадим url-адрес через имя url-а, которое мы указываем в urls.py
    1. В urls.py указываем имя url. path(<url>, <function>, name=<название пути>)
    2. В шаблоне(html-файле) в тегах <a> указываем href. href = "<% url '<название url>' %>"
    Example: <a href="{% url 'main' %}">...</a>
2) Создадим url-адреса с id для перемещения по страницам каталога или для чтения постов
    1. В urls.py создаём путь, который принимает id. path('woman/<int: id>', function, name='...')
    2. В views.py создаём функцию, которая принмает не только запрос(request), но ещё и id. def woman(request, id): ...
    3. В самой функции указываем, чтобы во время рендера странцицы передавалась запись из модели по полученному id.
    Example: return render(request, 'women/index.html', context={"info_woman": Women.objects.get(pk=id)} )

3) Создание абсолютного url адресса.
    1. Создание абсолютного url обусловлено тем, что это уменьшает шанс на ошибку. Мы будем формировать нужный url прямо в модели
    2. Переходим в models.py и создаём новый метод get_absolute_url(self, post_id).
    3. Внутри метода на возврат прописываем функцию reverse(<название url>, kwargs={исконное значение url: значение из модели})
    4. get_absolute_url() - создаёт ссылку по заданным параметрам при помощи фукции reverse
    Example: return reverse('post_actress', kwargs={"post_id": self.pk})
XIII. Связь моделей. --------------------------------------------------------------------------------------------------------------------------------

1) ForeignKey - Для связи многих с одной
    1. В изначальной таблице создаём ещё 1 поле cat_id, чтобы связываться с другой таблице.
    2. ForeignKey(<ссылка на первичную модель>, on_delete=<ограничения при удалении>). Первичная модель - это меньшая модель, которую мы будет подключать к изначальной
    3. on_delete = <ограничения при удалении> 
2) Создаём первичную молель(Category) для связи со вторичной(Women) и указываем связь между ними во вторичной(Women)
    1. Создаём обычную модель. ID не прописываем, поскольку оно будет создано автоматически
    2. Во вторичной модели создаём новый атрибут(cat) и присваиваем ему тип поля ForeignKey(<ссылка на первичную модель>, <ограничения удалении>)
    3. Перед созданием модели и внесением изменений в старую (создание миграции), нужно указать модели Women, что новое поле можно заполнять Null, поскольку в модели уже есть свои записи.
    4. Создаём миграцию(makemigration) и применяем её(migrate)
3) Заполнение новой модели
    1. Переходим в оболочку Django(shell)
    2. Добавляем новый записи в первичную модель(Category) через objects. Category.objects.create(name="Актрисы")
    3. Во вторичной модели в полу cat_id всех записей вписываем параметр 1, что является id на категорию Актрисы в первичной модели. Women.objects.all().update(cat_id=1)
4) Прикол вывода связанной таблица ForeignKey
    1. Обязатльно нужно прописать метод __str__(), который при выводе будет ссылатья не на объект, а на его название, благодаря этому можно будет выводить название рубрики

XIV. Работа с админ-панелью-----------------------------------------------------------------------------------------------------------------------------
    
1) Создание суперпользователя(superuser) и регистрируем модели
    1. python manage.py createsuperuser - создаёт аккаунта админа
    2. Вводим логин, пароль, почту
    3. В admin.py импортируем модели и регистрируем их. admin.site.register(<Модель>)
2) Настройка отображения модели в админ-панели
    1. В models.py к выбарнному классу(Women) дописываем специальный класс Meta, который и будет отвечать за отображение его в админ-панели
        class Meta: ...
    2. Для изменения отображения названия модели нужно присвоить специальной переменной verbose_name нужно название
        verbose_name = "Знаменитые женщины"
    3. Также Django частенько интегрирует своё множественное число, поэтому для множественного числа есть своя спец. переменна verbose_plural_name
        verbose_name_plural = "Много знаменитых женщин"
    4. Можно указать сортировку записей. "-" перед параметром означает обратную сортивровку
        ordering = [<основной параметр>, <вторичной параметр. Если 1-ые параметры одинаковые>]
Addition: 
    1) Меняем название app(Women). 
    1. В apps.py приложения в классе WomenConfig указываем специальную переменную verbose_name.
3) Подробная настрока отображения админ-панели
    1. В admin.py создаём класс WomenAdmin(admin.ModelAdmin).
    2. Отображение записи. В спец. переменной list_display указываем какие параметры выводить вместе с записями модели. 
        list_display = ('id', 'title', 'photo')
    3. Кликабельные поля. В спец. переменной list_display_links указываем какие параметры будут кликабельные(иметь ссылку)
        list_display_links = ('id', 'title')
    4. Поля, по которым можно вести поиск.  В спец. переменной search_fiels указываем по каким полям можно будет найти нужную запись
        search_fiels = ('title', 'content')
    5. Для передачи класса с параметрами(WomenAdmin) его нужно просто добавить к регистрации рядом с моделью
        admin.site.register(Women, WomenAdmin)
4) Работа с фотографиями.
    1. В админ-панели указываем путь к фотографии. После сохранения фото, в катологе media по заданому шаблону (photos/%Y/%m/%d/) создаются каталоги. На конце пути получаем указанную фотографию
    2. src = "{{ <объект>.photo.url }}" - для вызова фотографии на html странице

XV. Ползоавтельские теги шаблонов ------------------------------------------------------------------------------------------------------------------------

1) Для чего нужны пользовательские теги. DRY
    1. Для того чтобы избежать ненужных повторений. Например вызова модели несколько в разных view.
2) Создание функции для тега
    1. В приложении women создаём каталог "templatetags" и указываем, что это пакет посредсвом создание __init__.py
    2. Создаём файл, который будет хранить наши пользовательские теги. Можно использовать любое название.
        women_tags.py
    3. В women_tags.py импортируем: a) from django import Template b) from women.models import *
    4. Создаём функцию с произвольным именем, которая будет возвращаться часто повторяющиеся данные
        def get_categories():
            return Category.objects.all()
3) Превращаем функцию в полноценный тег
    1. Создаём переменную register к которой присваиваем экземпляр класса Library для регистрации тега в прокте.
        register = template.Library()
    2. Создаём декоратор перед функцией, который будет превращать нашу функцию в тег(simple_tag).
        @register.simple_tag()
            def get_categories(): ...

4) Использование тега в html.
    1. Загрузим наш тег в html файл.
        {% load women_tags %}
    2. Присваим значение функции определенной переменной при помощи конструкции. {% <функция> as <переменная> %}
        {% get_categories as categories %}
    3. Теперь можем использовать присвоенное значение вместо данных, который передавалсь в html через render
        {% for cat in categories %}
5) Виды и различия тегов.
    1. simple_tag - передаёт обыйчную коллекцию данных(QuerySet, списки и прочее)
    2. inclusion_tag - передаёт другой html файл с добавленными данными. Работак абсолютно так же как и include в jinja2
6) Работа inclusion_tag
    1. Создаём мини-шаблон, который будем интегрировать в основной.
    2. Создаём ещё 1 функцию в файле с тегами и добавляем ей декоратор inclusion_tag с html файлом, который будем вызвывать в основном файле
        @register.inclusion_tag('women/list_cats.html')
        def get_list_cats():
        # Возвращаем context, подобно тому как делается это во views
            return {"cats": cats}
7) Передача параметров тегам.
    1. Для начал нужно указать функциям, чтобы они принимали аргументы
        def get_categories(filter=None)
    2. Теперь в html файле можем передавать нужнын значения нашей функции как обычно, но без скобок
        {% get_categories filter=True %}

XVI. Использование slug-ов в url-адресах. -------------------------------------------------------------------------------------------------------------

1) Что такое slug и зачем он нужен
    1. slug - это уникальный идентифокатор, поддерживающий латиницу и цифры.  http://127.0.0.1:8000/women/emma-stone. "emma-stone" - это slug
    2. slug используются чащи при создании маршрутизации, поскольку slug-и легче ранжируются поисковиками и более доступны для пользователя 
2) Создадим сначала отображение постов
    1. Для вызова нужного записи из модели будем вызывать её по ключу через функцию get_object_or_404(<Модель>, <условие>)
        post = get_object_or_404(Women, pk = post_id)
    2. Передаём полученную запись в context и вываливаем всё на страницу
3) Создание slug-ов
    1. Сносим модель при помощи удаления всех мирграция и самой таблицы db.sqlite3
    2. Добавляем в модель новое полу - slug и указываем, что оно дожно быть уникальным и индексируемым.
        slug = models.SlugField(max_length=255, unique=True, db_index=True)
    3. Такое же поле добавляем и в категории.
4) Использование slug-ов и их автоматическое заполнение
    1. При создании новой записи теперь нужно заполнять и поле slug, но этого можно избежать.
    2. В admin.py в нужном классе отображения модели добавляем новый параметр, который будет записывать slug ссылаясь на title
    3. prepoluated_fields = {"slug": ("name",)}

XVII. Создание форм без связи с моделью. ---------------------------------------------------------------------------------------------------------------

1) Создание класса формы
    1. Добавляем в каталог app(women) новый файл forms.py, который содержит все формы приложения
    2. В forms.py создаём класс формы(class AddPostForm(forms.Form))
    3. В атрибуты класса добавляем только те поля, который нужно записывать вручную.
    4. forms.CharField() - тип поля в форме
    5. Для выбора параметра из связанной модели используется тип поля ModelChoiceField(queryset=Category.objects.all())
2) Создание формы в views и html-файле
    1. Передаём созданный класс(AddPostForm) в context.
    2. В html файле создаём специальный тег <form action="{% url '<view, который будет выводить форму>' %}" method="post">...</form>
        <form action="{% url 'add_page' %}" method="post">...<form>
    Внутри тега form:
        а) Прописываем защиту от копирования формы с целью обмана пользовтеля при помощи конструкции
            {% csrf_token %}
        б) Вывод полей формы через абзац(<p>)
            {{ form.as_p }}
        в) Кнопка для добавления данных
            <button type='submit'>Добавить</button>
3) Настройка повторного запроса формы
    # если мы получаем POST запрос, то будет проверять отправляемые данные от пользователя
        if request.method == "POST":
        # Присваиваем переменной данные заполненных полей формы через обработку POST запроса
            form = AddPostForm(request.POST)
        # Проверяем данные на валидность(правильное заполнение)
            if form.is_valid():
                print(form.cleaned_data())
        else:
            form = AddPostForm()
4) Формирование авторского отображения формы.
    1. При создании формы можно использовать свои стили.
    2. Для создания поля ввода достаточно вписать лишь нужное нам поле из класса формы
        {{ form.title }}
    3. Для полноценного создания формы обычно создают ещё label
        <p></p><label class='...' for='{{ form.title.if_for_label }}'>{{ form.title.label }}:</label>{{ form.title }}</p>
    4. Также стоит указать блок, куда будут выводиться ошибки при заполнении формы.
        <div class='...' >{{ form.title.errors }}</div>
    5. Если выводишь все формы через for, то у них будет 1 стиль оформления, но этого можно избежать прописав для них свой стиль в forms.py
    6. В forms.py у полей есть необязательный параметр widget, который позволяет настроить отображение поля.
        title = forms.CharField(widget=forms.TextInput(attrs={'class':'form-input'})) - добавляет к полю title своё оформление form-input
5) Добавление записи формы в модель
    1. Если форма валидна, то создаём новую запись в модели на основании данных формы и редиректим на главную страницу
        if form.is_valid():
            try:
                Women.objects.create(**form.cleaned_data)
                return redirect ("main")
    2. Если при создании формы возникла ошибка, то обрабатываем ошибку и выводим её через html конструкцию
        excep:
            form.add_error(None, 'Ошибка добавления поста')
        addpage.html:
            <div class="form-error">{{ form.non_field_errors }}</div>

XIII. Создание форм, связанных с моделями---------------------------------------------------------------------------------------------------------------

1) Создание формы на основание уже созданной модели.
    1. В forms.py создаём класс формы, который будет унаследовать параметры от forms.ModelForm
        class AddPostForm(forms.ModelForm): ...
    2. Внутри созданного класса создаём вложенный класс Meta, который будет указывать на какую модель ссылаться и какие поля брать.
        class Meta:
            model = Women
            #Берём все поля, который нужно заполнять вручную
            fields = "__all__" 
    3. Настройка отображения полей формы через специльный словарь widget
        widget = {
            'title' : forms.TextInput(attrs={'class':'form-input'})
        }
    4. Настройка отображения конктретныйх полей формы через вызов базовых методов класса.
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.fields['cat'].empty_label = 'Категория не выбрана'
    5. Сохраннее записи в модель после заполнения формы проиходи через метод save(), обращенный к записанным данным
        form = AddPostForm(request.POST)
        form.save()
2) Обработка файлов при создание записи модели при помощи формы
    1. В view.py при обработки формы AddPostForm запрашиваем не только request.POST, но и ещё request.FILES для получения чайлов
        form = AddPostForm(request.POST, request.FILES)
    2. В используемом шаблоне формы(addpage.html) в <form> добавляем 2-ой обязательный метод для обработки файлов enctype="multipart/from-data"
        <form class='...', method="POST", enctype="multipart/from-data"></form>

3) Пользовательские валидаторы
    1. Импортируем класс ValidationError для обработки ошибок
        from django.core.exceptions import ValidationError
    2. Создаём специльный метод - clean_<поле для валидации>
        def clean_title(self): ...
    3. Получаем данные поля title при помощи специльаного экземпляра cleaned_data
        title = self.cleaned_data['title']
    4. Прописываем условия, которые в случае исполнения будут приводить к ошибке 
        if len(title) > 200:
            raise ValidationError("Длина превышает 200 символов")
        
        return title

IXX. Классы представлений(views) ------------------------------------------------------------------------------------------------------------------------

1) Создание класс представления ListView(испольезуется для создания списка)
    1. Импортируем ListView
        from django.views.generic import ListView
    2. Создаём класс, который будет наследовать ListView
        class WomenHome(ListView): ...
    3. Указываем из какой-модели нужно брать данные при помощи специальной переменной model
        model = Women
    4. Прописываем путь к шаблону, на котором будут выводиться данные. Класс может создать свой путь автоматически
        Автоматический-сгенированный путь - <имя приложения>/<имя модели>_list.html - women/women_list.html
        Пользовательский путь - template_name = 'women/index.html'
    5. Вызов view в urls.py происходит при помощи указания <класс представления>.as_view()
        urlpatterns = [
            path('', WomenHome.as_view(), name='home')
        ]
2) Создание и работа с context-ом
    1. Для использования записей модели в шаблоне стоит прописать её название(context_object_name) или пользоваться сгенированным(object_list)
        context_object_name = 'posts'
    2. Для использования незменяемых объктов(строки, числа, кортежи и т.д.) на странице достаточно использовать extra_context
        extra_context = {'title':"главная странцица"}
    3. Для использования изменяемых объектов(списки, словари и т.д.) нужно создать специальный метод, который будет обрабатывать весь context класса
        def get_context_data(self, *, object_list=None, **kwargs):
            # Получаем context класса, который был уже указан
            context = super().get_context_data(**kwargs)
            # Добавляем нужные нам данные в context
            context['menu'] = menu
            return context
3) Настройка вывода записей модели
    1. Для того, чтобы отобразить записи модели, которые удовлетворяют нашему условию нужно создать спец.метод, который и будет выводить записи, прошедшие условия
        get_queryset(self):
            return Women.objects.filter(is_pubslished=True)
4) Создание модели "Category" с использованием связей БД для использования slug
    1. Создаём класс представавления аналогичный WomenPost, за исключением отображения
    2. В методе get_queryset() прописываем фильтр, который будет вызывать запись, когда переданный slug в url будет совпадать с slug-ом категории модели
        def get_queryset(self):
            return Women.objects.filter(cat__slug = self.kwargs["cat_slug"])
    3. Данные передаваемые через url можно получить через kwargs.
        self.kwargs['cat_slug']
5) Создание контескта с помощью данных из модели
    1. Создаём специальный метод get_context_data()
        def get_context_data(self, *args, object_list=None, **kwargs)
    2. Сохраням уже указанный context
        context = super().get_context_data(**kwargs)
    3. Для вызова данных из модели используется следующая запись - context[<название модели, которое дали в классе>][<номер записи>].<поле>
        context['title'] = context['posts'][0].cat
    4. Обработка ошибки пустого спика. Если список пустой, то выдаст 404
        allow_empty = "False"

6) Класс представления DetailView
    1. DetailView используется для отбражения поста
    2. Класс создаётся аналогично ListView
        а) Создаёшь класс, который наследует DetailView
        б) Указываешь модель (model)
        в) Указываешь путь к шаблону (template_name)
        г) Указываешь имя модели (context_object_name)
    3. Особенность DetailView - при получении переменной из url нужно указать в классе её название(<тип данных>_url_kwarg) или же класс будет использовать значение по умолчанию, которое представляет из себя просто 'slug' или 'pk' и т.д.
        slug_url_kwarg = 'post_slug' - указывает на запись модели по полученнуому slug-у
    4. DetailView делаёт всё сам, так что тебе не нужно вызывать запись из модели по slug или по pk, чтобы получить её
    5. Если поле со slug-ом называется в модели не 'slug', то перед этим нужно указать поле, в котором содержиться slug-значение
        slug_field = 'url'
7) Класс представавления CreateView
    1. CreateView используется для отображения форм
    2. Класс создаётся практически так же как ListView, но вместо model указывается form_class = <класс формы>
        а) Создаёшь класс, который наследует CreateView
        б) указываешь форму (form_class = AddPostForm)
        в) указываешь путь к шаблону (template_name)
    3. Особенность CreateView - после создания формы тебя сразу редиректит по ссылке указанной в используемой модели(get_absolute_url)
    4. Чтобы избежать автоматического редиректа можно использовать специальную переменную success_url и функцию return_lazy(<название url>)
        success_url = return_lazy("main")

XX. Основы ORM -----------------------------------------------------------------------------------------------------------------------------------------

1) Возможности использования ORM
    1. Women.objects.all()[:5] - Выводит первые 5 элементов
    2. Women.objects.order_by('pk') - Сортирует записи модели по pk. Для обратной соритровки исползуем "-" перед параметром('-pk')
    3. Women.objects.filter(pk__lte=2) - Выводит записи, у который pk <= 2.
        а) pk__lte = 2 - pk <= 2
        б) pk_gte = 2 - pk >= 2
    4. Women.objects.get(pk = 2) - Выводит одну запись, подходящую под условие
2) Обращение к связанной модели
    1. Women.objects.get(pk=2).cat - выведет экземпляр свяазнной модели через id, хранящийся в cat
    2. Women.objects.get(pk=2).cat.name - Выведет уже атрибут экземпляра связанной модели
    3. Category.objects.get(pk=1).<вторичная модель(women)>_set.all(). - Выведот все записи вторичной модели(women), которые содержат экземпляр "Актрисы", полученные из категории через pk=1
3) Параметры filter
    1. Women.objects.filter(title__contains='ли') - Выводит записи, у которых в поле title есть 'ли'. title__icontains='ЛИ' - без учёта регистра
    2. Women.objects.filter(pk__in=[2,4,6,7]) - Если pk есть в списке [2,3,6,7], то выводит эту запись
4) Логические операторы
    1. from django.db.models import Q - Для использования логические операторов импортируем модуль Q
        а) & - "И"
        а) | - "ИЛИ"
        а) ~ - "НЕ"
    2. Women.objects.filter(Q(pk__gt = 5) | Q(cat_id=2)) - Выводит записи, у которых id > 5 ИЛИ cat_id == 2
5) Фильрация по времени создания или изменения.
    1. Women.objects.latest('time_create') - Выводит запись, которая была добавленая позже всех
    2. Women.objects.earliest('time_create') - Выводит запись, которая была добавленая раньше всех
    3. Women.objects.get(pk=7).get_previous_by_time_create() - Выводит первую запись, которая была создана ПЕРЕД записью pk=7
    4. Women.objects.get(pk=7).get_next_by_time_create() - Выводит первую запись, которая была создана ПОСЛЕ записи pk=7
    5. Women.objects.get(pk=7).get_next_by_time_create(pk__gt = 9) - Выводит первую запись, которая была создана ПОСЛЕ записи pk=7 и у которой pk > 9
6) Методы, используеммые для проверки и подсчёта записей
    1. exist() - проверяет на существование записе
        c3 = Category.objects.create('...')
        check = Category.objects.get(pk = 3)
        check.women_set().exits() - True or False
    2. Women.objects.all().count() - Отобразит количество записей в модели
7) Обращение к первично модели через вторичную в filter
    1. Women.objects.filter(cat__slug = 'aktrisy') - Выводит записи, у которых поле cat ссылается на запись во вторичной модели, у которой slug = 'aktrisy'
    2. Category.objects.filter(women_title_contains = 'ли') - Выводит записи, которые связаны с полями women_title, которые содержат 'ли'
        <связанная модель>__<поле связанной модели> = 'aktrisy'
    3. Category.objects.filter(women_title_contains = 'ли').distinct() - выводит только уникальные значения
8) Агрегаторы ORM
    1. from django.db.models import * - импортируем все аргегируюзие функции
    2. Формат записи - Women.objects.aggregate(<спец. агрегатор>("поле"))
    3. На выходе получаем словарь - {<поле>__<агрегатор>} - {"cat_id__min": 1}. 
    4. Значение ключей можно менять при помощи указания имени ключа при вызове агрегатора -  Women.objects.aggregate(cat_min = Min('cat_id'))
    4. Women.objects.aggregate(Min('cat_id')) - Выводит минамальное значение поля cat_id
    5. Со значениями агрегаторов можно проводить арифметичические операции
        Women.objects.aggregate(res = Sum('cat_id') + Count('cat_id')) # res = 26
    6. Women.objects.aggregate(Avg('cat_id')) - Выводит среднее арифметичическое
9) Метод ORM
    1. values() - используется для вызова конкретних полей из модели, а не всех, что увеличивает скорость обработки запроса
    2. Women.objects.values('title', 'cat_id')
    3. Women.objects.values('cat_id').annotate(x = Count('id'))
        а) values('cat_id') - группируем по id
        б) annotate(x = Count('id')) - Подчиствает количество id в группах
    4. c = Category.objects.annotate(Count(<первичная модель>)) - отобразит связанные данные
        c[0].women__count - Отобразит количество 1-го объекта в модели women
    5. c = Category.objects.annotate(total=Count('women')).filter(total__gt=0) - Выводит только категории, у которых записей > 0
    6. annotate(len=Length('title')) - создаёт переменную(len), которая хранит в себе результат указанной функции(Length) 
10) Класс F
    1. Класс F используется для использования значений других полей в условиях
        Women.objects.filter(pk_gt=F('cat_id')) - pk > cat_id
    2. Для использования класс F его нужно импоритровать 
        from django.db.models import F
11) ORM функции
    1. ORM фунции очень часто похожи на обыкновенные функции python. ORM: Length(), Py: len()
    2. Импортируем функции 
        from django.db.models.functions import *
    3. Women.objects.annotate(len = Length('title')) - каждый экземпляр модели имеет доп.атрибут с длинной поля title
12) Manager raw
    1. Manager raw используется для выполнения SQL-запроса вручную
    2. Формат записи - Women.objects.raw('SELECT * FROM women_women') 

XXI. Mixins - убираем дублирование кода ------------------------------------------------------------------------------------------------------------------

1) Предназначение Minxins
    1. Используются, когда необходимо убрать повторяющийся блок кода
2) Создание и использование Mixin-ов
    1. Создаём файл utils.py в каталоге приложения(women)
    2. Создаём класс DataMixin, в который передаём повторяющийся код, а именно метод get_user_context(self, **kwargs)
        Class DataMixin:
            def get_user_context(self, **kwargs):
            # Сохраняем переданные именнованые параметры в context
                context = kwargs
            # Прописываем повторяющийся код
                context['cats'] = Category.objects.all()
                context['menu'] = menu
            # Если cat_selected не указано, то присваиваем ей 0
                if 'cat_selected' not in context:
                    context['cat_selected'] = 0
            # Возращаем полученный context
            return context
    3. В views.py Указываем в классе представления наследование от класс DataMixin
        class WomenHome(DataMixin, ListView)
    4. Убираем повторяющийся код, который уже указан в DataMixin
    5. Остальные атрибуты можно добавить при помощи вызова метода из DataMixin
        ad_context = self.get_user_context(title='Главная страница')
    6. Метод должен возвращать оба context-а
        return dict(list(context.items) + list(add_context.items))
3) Стандартный Mixin - LoginRequiredMixin
    1. LoginRequiredMixin ипользуется для проверки пользователя, залогинен он или нет.
    2. Чтобы использовать LoginRequiredMixin достаточно добавить его в класс представления.
        class AddPage(LoginRequiredMixin, DataMixin, CreateView)
    3. Если пользователь не авторизован, то странци отобразит ошибку 404. Это не очень удобно, поэтому стоит прописать редирект через login_url = reverse_lazy(<Название маршрута>)
        login_url = reverse_lazy('main')
    4. Вместо редиректа можно выдать страницу с ошибкой 403 - доступ запрещён
        raise_exception = True
    5. Проверка аторизации пользователя через полученный request можно осуществить при помощи request.user.is_authenticated
    6. Пропишем условие, что не будем выводить часть menu если пользователь не авторизован в Mixin
        clas DataMixin: 
            def get_user_context(self, **kwargs):
                ...
                user_menu = menu.copy()
                if not self.request.user.is_authenticated:
                    user_menu.pop(1)
                context["menu"] = user_menu
XXII. Постраничная навигация(Пагинцация) ----------------------------------------------------------------------------------------------------------------

1)Класс Paginate
    1. Paginator(<Данные>, <кол-во записей на 1 страцице>) - формат записи класса
        pages = Paginator(['john', 'paul', 'george', 'ringo'], 2)
    2. В классе представления ListView класс Paginator встроен в специальную переменную paginate_by = <количество записей>
        paginate_by = 3
    3. В html файл создаём навигацию при помощи прохода циклом 
        {% for p in paginator.page_range %} - класса ListView
        {% for p in page_obj.paginator.page_range %} - для остальных
    4. В цикле формируем ссылки на страницы
        <a href="?page={{ p }}">{{ p }}</a>
    5. page_obj.number - указывает текущею страницу
    6. Указываем текущею страницу в навигации(Убираем ссылку с текущей страницы)
        {% if page_obj.number == p %}
            <li>{{ p }}</li> 
        {%  else %}
            ...
        {% endif %}
    7. {% if page_obj.has_other_pages %} - будет проверяеть наличие других страниц. Используется, чтобы не отображать навигацию, когда нет других страниц
        {% if page_obj.has_other_pages %}
            <nav>
                ...
            </nav>
        {% endif %}
2) Рациональная навигация
    1. Сделаем так, чтобы на странице отображалась не вся навигация, а только ближайшие 2 страницы
    2. Это можно сделать при помощи условия, которое будет выводить только те страницы, которые:
        а) Меньше текущей на 2 (page_obj.number|add:-2)
        б) Больше текущей на 2 (page_obj.number|add:2)
        {% elif page_obj.number|add:2 >= p >=  page_obj.number|add:-2 %}
            ...
3) Кнопки next и back в пагинаци
    1. Проверим есть ли следующая страница и если True, то выведем ссылку на в навигации. Аналогично и с движением назад
    2. Будем использовать методы page_obj.has_next для проверки и page_obj.next_page_number для вывода ссылки
    